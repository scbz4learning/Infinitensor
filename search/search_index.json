{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Scbz's blog of learning Infinitensor 2025 Summer","text":""},{"location":"#stage-0","title":"Stage 0","text":""},{"location":"#stage-1","title":"Stage 1","text":""},{"location":"0/","title":"Stage 0","text":""},{"location":"0/#day-01-rustlings-00-10","title":"Day 01 - rustlings 00-10","text":"<p>Selected questions</p>"},{"location":"0/#variables","title":"Variables","text":"<ol> <li>must use <code>let</code>, type can be inferred automatically, except <code>const</code>.  </li> <li><code>const</code> must be named with a type.  </li> <li>Only var with <code>mut</code> can be mutable.  </li> <li>vars can be shadowing with a new type/ value.   </li> </ol>"},{"location":"0/#move-semantics","title":"Move Semantics","text":"<p>Just remind: 1. One variable one ownership 2. Variable can be borrowed, but there is at most 1 mutable borrow simultaneously   </p>"},{"location":"0/#structs","title":"Structs","text":"<ul> <li> why we need \"UnitStructs\"?  </li> </ul>"},{"location":"0/#string-and-str","title":"<code>String</code> and <code>&amp;str</code>","text":"<ul> <li> The methods are weird... Some methods can change the type while somes are not...</li> </ul>"},{"location":"0/#vec","title":"Vec","text":"<p><code>input.iter().map(|element| element + 1).collect()</code>, just like lambda in python.  </p>"},{"location":"0/#modules","title":"Modules","text":"<ul> <li> Like a class without attribute members?  </li> <li>No... It is same as <code>#include</code> while class methods are defined by <code>impl</code>.  </li> </ul> <p>For the general cases:  </p> \u6982\u5ff5 C++ \u5bf9\u5e94 Rust \u5bf9\u5e94 \u7c7b\u578b\u5b9a\u4e49 <code>struct</code>, <code>class</code> <code>struct</code>, <code>enum</code> \u65b9\u6cd5 \u6210\u5458\u51fd\u6570 <code>impl</code> \u5757\u4e2d\u7684\u65b9\u6cd5 \u63a5\u53e3/\u62bd\u8c61 \u62bd\u8c61\u7c7b, \u865a\u51fd\u6570 <code>trait</code> + <code>impl</code> \u6a21\u5757/\u547d\u540d\u7a7a\u95f4 <code>namespace</code>, <code>.h</code> \u6587\u4ef6 <code>mod</code>, <code>use</code>, <code>crate</code> \u5b8f <code>#define</code>, <code>template</code> <code>macro_rules!</code>, <code>macro</code> \u53ef\u9009\u503c \u6307\u9488\u6216 <code>std::optional</code> <code>Option&lt;T&gt;</code> \u9519\u8bef\u5904\u7406 \u5f02\u5e38 (<code>try/catch</code>) <code>Result&lt;T, E&gt;</code> \u5185\u5b58\u7ba1\u7406 \u624b\u52a8\u6216\u667a\u80fd\u6307\u9488 \u6240\u6709\u6743\u7cfb\u7edf + \u751f\u547d\u5468\u671f"},{"location":"0/#day-02-rustlings-11-13","title":"Day 02 - rustlings 11-13","text":""},{"location":"0/#hashmaps","title":"Hashmaps","text":"<ol> <li><code>use</code> </li> <li>Create: <code>let mut map = HashMap::new();</code> </li> <li>Insert:   <ol> <li>Must exist: <code>map.insert(key, value)</code> </li> <li>Not sure: <code>map.entry(key).or_insert(value)</code> </li> </ol> </li> <li>Get: <code>map.get(key)</code> -&gt; <code>Some(value)</code> </li> <li>Loop:  <ol> <li>Readonly: <code>for (key, value) in &amp;map {}</code> </li> <li>Mutable: <code>for (key, value) in &amp;mut map {}</code> </li> <li>for keys / values only: <code>for key in map.keys()</code>, <code>for value in map.values()</code> </li> <li><code>map.iter()</code> </li> <li>Consumable iteration (move the ownership, i.e. cannot be used next time): <code>map.into_iter()</code> </li> </ol> </li> <li>Update:  <ol> <li>Must exist: <code>map.insert(key, value)</code> </li> <li>Not sure: <code>map.and_modify(key, value)</code> </li> </ol> </li> <li>Remove: <code>map.remove(key, value)</code> </li> </ol> <p><code>hashmaps2.rs</code> \u4f3c\u4e4e\u6709\u95ee\u9898\uff0c47\u52a0\u4e00\u4e2a<code>use</code>\u53ef\u4ee5\u89e3\u51b3 <pre><code>44     #[cfg(test)]\n45     mod tests {\n46         use super::*;\n47 +++     use std::iter::FromIterator;\n</code></pre></p> <p><code>hashmaps3.rs</code> is quite interesting  </p> <p>Here is my implementation, which is obviously stupid...   <pre><code>scores.entry(team_1_name)\n    .and_modify(|v| {v.goals_scored += team_1_score; v.goals_conceded += team_2_score})\n    .or_insert(TeamScores{goals_scored: team_1_score, goals_conceded: team_2_score});\nscores.entry(team_2_name)\n    .and_modify(|v| {v.goals_scored += team_2_score; v.goals_conceded += team_1_score})\n    .or_insert(TeamScores{goals_scored: team_2_score, goals_conceded: team_1_score});\n</code></pre></p> <p>The solution is quite interesting: <pre><code>// Insert the default with zeros if a team doesn't exist yet.\nlet team_1 = scores.entry(team_1_name).or_default();\n// Update the values.\nteam_1.goals_scored += team_1_score;\nteam_1.goals_conceded += team_2_score;\n\n// Similarly for the second team.\nlet team_2 = scores.entry(team_2_name).or_default();\nteam_2.goals_scored += team_2_score;\nteam_2.goals_conceded += team_1_score;\n</code></pre></p> <ol> <li><code>or_default()</code> will insert a default value into hash maps when there is no such entry. The default values of some types are:      <ul> <li> \u7c7b\u578b <code>Default::default()</code> \u7684\u503c <code>u8</code> <code>0</code> <code>bool</code> <code>false</code> <code>String</code> <code>\"\"</code> <code>Vec&lt;T&gt;</code> <code>[]</code> <code>Option&lt;T&gt;</code> <code>None</code> </li> </ul> </li> <li><code>or_default</code> -&gt; <code>mut &amp;</code>, i.e. it will return a mutable reference, so changing team_1 is changing the bucket.  </li> </ol>"},{"location":"0/#options","title":"Options","text":"<p>Just <code>Some(...)</code> and <code>None</code> </p> <p>However, the usage of <code>match</code> is appalled: <code>match</code> will move the ownership when matching! </p>"},{"location":"0/#error-handling-results","title":"Error Handling (Results)","text":"<p>1-3 and 5 are basic questions.</p>"},{"location":"0/#errors4rs","title":"<code>errors4.rs</code>","text":"<p>Understanding: 1. <code>#[derive(...)]</code> is a <code>macro</code>, using it can add common traits to structs and enums. 2. <code>#[derive(PartialEq, Debug)]</code> add traits <code>PartialEq</code> and <code>Debug</code> to the struct <code>PositiveNonzeroInteger</code>, so that:     1. <code>PartialEq</code> can deal with equality test without changing types of both sides to be exactly same. This is wrong! The types of sides of equality test must be the same. However, it is the trait that enables the equality test to make sense. Without it, there is no defination in the struct and its implementation for , !.          -  For example, assert_eq!(PositiveNonzeroInteger::new(10), Ok(PositiveNonzeroInteger(10)));  will not yield an error, although the left is a struct and the right is the struct wrapped into an result. They are in the same types. The new impl returns an result as well!  Remember, both sides must be in the same type. However, without PartialEq, the == cannot be recognised.         -  Comparing PositiveNonzeroInteger::new(10) &gt;= PositiveNonzeroInteger::new(8) is not applicable here, as PartialEq only deal with equality test, while the comparisons are handled by the trait*s PartialOrd (may fail and return None Best effort. If not compariable, return None. e.g. comparing any float number with <code>NaN</code>) or Ord (must use with PartialEq and PartialOrd. Will never fail but may be over-compared Will always give a boolean result or the program will crash. e.g. we may not need a real comparison for a float number and a string We cannot compare a float with a string, the both sides must be in the same type. e.g. comparing any float number with <code>NaN</code> in <code>Ord</code> will crash the program as there is not such trait applied, which is because this camparison is logically nonsense).      2. <code>Debug</code> enables <code>{:?}</code> and <code>{:#?}</code> in <code>println!</code> 3. <code>Self</code> means the *impl <code>PositiveNonzeroInteger</code>. (Nothing special here, just like <code>self</code> in python.)  </p> <p>For implementation, <code>if value &gt;/==</code> is trivial: <pre><code>if value &gt; 0 {\n    // value is i64 and we need u64 inside the struct\n    // use `as` to cast the type\n    Ok(PositiveNonzeroInteger(value as u64)) \n} else if value == 0 {\n    Err(CreationError::Zero)\n} else {\n    Err(CreationError::Negative)\n}\n</code></pre> Although complicated, there is no issue. <code>match</code> is useful as well, the comparison can be handled in braches: <pre><code>match value {\n    n if n &gt; 0 =&gt; Ok(PositiveNonzeroInteger(n as u64)), // handle the postive part\n    0 =&gt; Err(CreationError::Zero),\n    _ =&gt; Err(CreationError::Negative),\n}\n</code></pre> However, there is a fancy and idiomatic (\u5730\u9053\u7684, \u4e60\u8bed\u7684, \u6210\u8bed\u7684, \u5408\u4e4e\u8bed\u8a00\u4e60\u60ef\u7684) method, given in the sample solution: <pre><code>use std::cmp::Ordering;\nmatch value.cmp(&amp;0) {\n    Ordering::Less =&gt; Err(CreationError::Negative),\n    Ordering::Equal =&gt; Err(CreationError::Zero),\n    Ordering::Greater =&gt; Ok(Self(value as u64)),\n}\n</code></pre> <code>impl Ord</code> for <code>i64</code> gives <code>fn cmp</code>, the return value is of type <code>Ording</code>, which is a enum with only 3 values: <pre><code>#[repr(i8)]\npub enum Ordering {\n    Less = -1,\n    Equal = 0,\n    Greater = 1,\n}\n</code></pre></p>"},{"location":"0/#errors6rs","title":"<code>errors6.rs</code>","text":""},{"location":"0/#now-how-can-we-handle-errors","title":"Now how can we handle errors?","text":"<ol> <li>We can (obviously we do not want) let it crash, by compiler errors, or <code>panic</code> (just like <code>assert</code> in python)  </li> <li>Just like <code>try</code> and <code>except</code> in python, we can handle the known issue we might have and let the program continues. We use <code>Result&lt;T, E&gt;</code> syntax in rust with reasons in <code>E</code>, like <code>TypeError</code> in python.  <ol> <li>For catch-all. Sometimes we do not care about why, just like <code>except</code> without specific error in python. we can use <code>Box&lt;dyn Error&gt;</code> in <code>errors5.rs</code> or just self-buit message like <code>Err(format!(\"Empty names aren't allowed\"))</code> in <code>errors1.rs</code>. However, these are not standarised for re-use.  </li> <li>Preferably, we define the error types in <code>enum</code> (now like C) and then map the error for readability.  </li> </ol> </li> </ol> <p>Here, we first create the enum if error types</p> <pre><code>use std::num::ParseIntError;\n\n#[derive(PartialEq, Debug)]\nenum CreationError {\n    Negative,\n    Zero,\n}\n</code></pre> <p>Then, we need an impl to parse the error - just like in python, to give definition of the process that <code>5 + \"1\"</code> will raise <code>TypeError</code>. But *impl*s cannot exist themself, we need a enum to place them:  </p> <pre><code>#[derive(PartialEq, Debug)]\nenum ParsePosNonzeroError {\n    Creation(CreationError),\n    ParseInt(ParseIntError),\n}\n\nimpl ParsePosNonzeroError {\n    fn from_creation(err: CreationError) -&gt; Self {\n        Self::Creation(err)\n    }\n\n    // TODO: Add another error conversion function here.\n    fn from_parse_int(err: ParseIntError) -&gt; Self {\n        Self::ParseInt(err)\n    }\n}\n</code></pre> <p>The enum <code>ParsePosNonzeroError</code> gives almost nothing, just wrap the enum <code>CreationError</code> and <code>ParseIntError</code> (using from std) again. However, with their helps, we can now give impl to translate them. Note that there is noway to give one enum only, as the <code>CreationError</code> and <code>ParseIntError</code> are handlers where <code>ParsePosNonzeroError</code> is the process. </p> <p>The impl will take the handler in as an argument and then return an error of its *variant*s.</p>"},{"location":"0/#creationerror-internal","title":"<code>CreationError</code> internal","text":"<p>Lets see the process of  <pre><code>#[test]\nfn test_zero() {\n    assert_eq!(\n        PositiveNonzeroInteger::parse(\"0\"),\n        Err(ParsePosNonzeroError::Creation(CreationError::Zero)),\n    );\n}\n</code></pre></p> <p>The <code>\"0\"</code> is parsed by <code>PositiveNonzeroInteger::parse()</code></p> <pre><code>impl PositiveNonzeroInteger {\n    fn new(value: i64) -&gt; Result&lt;Self, CreationError&gt; {\n        match value {\n            x if x &lt; 0 =&gt; Err(CreationError::Negative),\n            0 =&gt; Err(CreationError::Zero),\n            x =&gt; Ok(Self(x as u64)),\n        }\n    }\n\n    fn parse(s: &amp;str) -&gt; Result&lt;Self, ParsePosNonzeroError&gt; {\n        // TODO: change this to return an appropriate error instead of panicking\n        // when `parse()` returns an error.\n        let x: i64 = s.parse().unwrap()...;\n        Self::new(x).map_err(ParsePosNonzeroError::from_creation)\n    }\n}\n</code></pre> <p>First, the <code>fn parse</code> deal with <code>\"0\".parse()</code>. <code>str.parse()</code> is to parse any <code>&amp;str</code> into another type, wrapped by <code>Result &lt;T,E&gt;</code>, which is so general, so the type must be known for compiler. For example  </p> <pre><code>let x = \"0\".parse(); // Error, the compiler does not know the type of x\nlet x:i32 = \"0\".parse(); // Error, the return value of `parse()` is wrapped in `Result &lt;T, E&gt;` \nuse std::num::ParseIntError;\nlet x:Result&lt;i32, ParseIntError&gt; = \"0\".parse(); // Works, but rare. x = Ok(0)\n\nlet x:i32 = \"0\".parse().unwrap(); // Good, the compiler infer \"0\".parse() to be i32\nlet x = \"0\".parse::&lt;i32&gt;().unwrap(); // Good, the compiler infer x to be i32, as the type of \"0\".parse() is specified by generic syntax\n</code></pre> <p>So now, we ignore the error handling <code>...</code> after <code>s.parse().unwrap()</code> and get <code>x:i64=0</code>. We now pass the <code>x</code> to <code>Self::new(x)</code>, which is <code>PositiveNonzeroInteger:new(x)</code>. The <code>new()</code> does <code>match</code> and find return <code>Err(CreationError::Zero)</code>. Now, we handle the error: <code>Err(CreationError::Zero).map_err(ParsePosNonzeroError::from_creation)</code>. From the basics, the <code>map_err</code> just map all errors (here is <code>Err(CreationError::Zero)</code>) to a specific error <code>Err&lt;e&gt;</code>, where e is returned by a process (here is <code>ParsePosNonzeroError::from_creation</code>). The process <code>ParsePosNonzeroError::from_creation</code> is a <code>impl fn</code>, which is just like function pointer in C. The process <code>ParsePosNonzeroError::from_creation</code> get <code>CreationError::Zero</code> as an argument and find the type is correct (as the parameter is defined as <code>err: CreationError</code>). Now, it will give the return value as <code>e = ParsePosNonzeroError::Creation(CreationError::Zero)</code>. The <code>map_err()</code> will wrap the <code>e</code> into an <code>Err&lt;&gt;</code>, therefore, the final result is <code>Err(ParsePosNonzeroError::Creation(CreationError::Zero))</code>, which is correct!  </p>"},{"location":"0/#fix-to-do","title":"Fix <code>to do</code>","text":"<p>Now, we need to think about what we ignore. If <code>&amp;str.parse()</code> fails, the program will crash when <code>unwrap()</code>. To deal with this, we can match the result:  </p> <pre><code>// this is how we init Result&lt;T,E&gt; var\nlet res = s.parse::&lt;i64&gt;();\nmatch res {\n    Ok(v) =&gt; Self::new(v).map_err(ParsePosNonzeroError::from_creation),\n    Err(e) =&gt; Err(e).map_err(ParsePosNonzeroError::from_parse_int)\n}\n</code></pre> <p>However, a better way is:</p> <pre><code>fn parse(s: &amp;str) -&gt; Result&lt;Self, ParsePosNonzeroError&gt; {\n    // Return an appropriate error instead of panicking when `parse()`\n    // returns an error.\n    let x: i64 = s.parse().map_err(ParsePosNonzeroError::from_parse_int)?;\n    Self::new(x).map_err(ParsePosNonzeroError::from_creation)\n}\n</code></pre> <p>If <code>s.parse()</code> is successful, then value inside <code>Ok()</code> is extracted and assigned to <code>x</code>; Otherwise, it raises <code>Err(ParseIntError)</code>. Then  <code>Err(ParseIntError)</code> will be mapped by the process of <code>ParsePosNonzeroError::from_parse_int</code>, from <code>Err(ParseIntError)</code> to <code>Err(Self::ParseInt(err))</code>. Therefore, the final result of this line should be either      - <code>x</code> is assigned to some <code>i64</code> and then use <code>new()</code> to find the creation error,     - or return <code>Err(ParsePosNonzeroError::ParseInt(ParseIntError))</code>.   </p>"},{"location":"0/#a-standarised-way-from-trait","title":"A Standarised Way - <code>From</code> Trait","text":"<p>This is actually a manual built <code>From</code> trait. A better way is:  </p> <pre><code>#[derive(PartialEq, Debug)]\nenum ParsePosNonzeroError {\n    Creation(CreationError),\n    ParseInt(ParseIntError),\n}\n\n// \u6807\u51c6\u5316\u7684 From \u5b9e\u73b0\nimpl From&lt;CreationError&gt; for ParsePosNonzeroError {\n    fn from(err: CreationError) -&gt; Self {\n        ParsePosNonzeroError::Creation(err)\n    }\n}\n\nimpl From&lt;ParseIntError&gt; for ParsePosNonzeroError {\n    fn from(err: ParseIntError) -&gt; Self {\n        ParsePosNonzeroError::ParseInt(err)\n    }\n}\n</code></pre> <p>Now, the creation error is handled in a standarised way. We can now simplify the <code>fn parse()</code>:  </p> <pre><code>fn parse(s: &amp;str) -&gt; Result&lt;Self, ParsePosNonzeroError&gt; {\n    let x: i64 = s.parse()?; // the mapping is handled via `From` automatically\n    let v = Self::new(x)?; // the mapping is handled via `From` automatically\n    Ok(v) // The v is now unwrapped if successful. To make return value in the same type, wrap it again.\n}\n</code></pre>"},{"location":"0/#map_err-internal","title":"<code>map_err</code> Internal","text":"<p>What is <code>map_err</code>? What are the parameters?</p> <p><code>pub fn map_err&lt;F, O&gt;(self, op: O) -&gt; Result&lt;T, F&gt;</code> where <code>O: FnOnce(E) -&gt; F,</code> </p> <p>Maps a Result to Result by applying a function to a contained Err value, leaving an Ok value untouched.   <p>This function can be used to pass through a successful result while handling an error.</p> <p>Examples  </p> <pre><code>fn stringify(x: u32) -&gt; String { format!(\"error code: {x}\") }  \n\nlet x: Result&lt;u32, u32&gt; = Ok(2);  \nassert_eq!(x.map_err(stringify), Ok(2));  \n\nlet x: Result&lt;u32, u32&gt; = Err(13);  \nassert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));  \n</code></pre> <p>Given <code>a:&lt;Result&lt;T,E&gt;&gt;</code> <code>a.map_err(Op)</code> is equivlent to a <code>match</code> statement:   </p> <pre><code>match a {\n    Ok(v) =&gt; Ok(v), // leave the T part not touched\n    Err(e) =&gt; Err(Op(e)),\n};\n</code></pre> <p>where <code>Op: FnOnce</code> is a one-time (means the ownership will be moved after the first call -  we do not want to an error twice) function pointer or closure pointer. <code>Op(e)</code> will return another <code>e</code>, which is why it is called <code>map_err()</code>.  </p>"}]}